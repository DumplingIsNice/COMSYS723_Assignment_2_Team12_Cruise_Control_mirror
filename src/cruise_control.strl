 % Created by Hao Lin and Chamith Nanayakkara
% Implementation of a cruise control software using ESTEREL.
% This .strl file implements the control component of the software

% Log: 
% 17/05/22 version - Chamith Nanayakkara - PI_controller implementation branch
% 26/05/22 version - Chamith Nanayakkara - cruise_speed_updater implementation branch
 
 %{ Top Level Module: cruise_control }%
 module cruise_control:

input On;
input Off;
input Resume;
input Set;
input QuickAccel;
input QuickDecel;
input Accel : float;
input Brake : float;
input Speed : float;


output CruiseSpeed : float;
output ThrottleCmd : float;
output CruiseState : integer;


	[loop
		% testing the cruise state = 2
		emit CruiseState(2);
		pause;
		 
	end loop]
	||
	[run cruise_speed_updater[ signal Set/set_cruise_speed; 			  
				   signal Speed/speed;
				   signal QuickAccel/quick_accel_pressed;
				   signal QuickDecel/quick_decel_pressed;				    
				   signal CruiseState/cruise_state;				   
				   signal CruiseSpeed/cruise_speed ]]
	||
	[run PI_controller[ 	signal CruiseSpeed/cruise_speed_PI;
				signal Speed/current_speed;
				signal ThrottleCmd/throttle_cmd ]]; 
	 		 
end module



% Module: PI_controller

module PI_controller:

input cruise_speed_PI : float; 
input current_speed : float;
output throttle_cmd : float;

function regulateThrottle(integer, float, float) : float;
 
loop
	% for testing set isGoingOn = 0
 	emit throttle_cmd(regulateThrottle(0, ?cruise_speed_PI, ?current_speed));
	pause;
end loop

end module

 
%Module: cruise_speed_updater
 
module cruise_speed_updater:
 
 constant speed_min = 30.0f  : float;
 constant speed_max = 150.0f : float;
 constant speed_inc = 2.5f   : float;
 
 input set_cruise_speed;
 input speed: float; 
 input quick_accel_pressed;
 input quick_decel_pressed;
 input cruise_state: integer;
 
 output cruise_speed: float;

 var current_speed := 0.0f :float in
 
 	loop
 		% set the cruise speed to 0 at the start, and to the current speed after
 		emit cruise_speed(current_speed);
 		pause;
 		
 		trap trap_loop in
 		
 			% OFF state
 			if (?cruise_state = 1) then
 				current_speed := 0.0f;
 				exit trap_loop;
 				
 			% ON, STDBY, or DISABLE states
 			else
 				% If the ON is just pressed and the previous is OFF state, load the current_speed
 				if((pre(?cruise_state) = 1) and (?cruise_state = 2)) then 					
 					% set the speed
 					current_speed := ?speed;					
 					% Limits the speed
			 		if (current_speed > speed_max) then
						current_speed := speed_max;						
					end if;
					if (current_speed < speed_min) then
						current_speed := speed_min;						
					end if;					 
					exit trap_loop; 				
 				end if;
 				
 				present set_cruise_speed then
 					% set the speed
			 		current_speed := ?speed;
			 		% Limits the speed
			 		if (current_speed > speed_max) then
						current_speed := speed_max;						
					end if;
					if (current_speed < speed_min) then
						current_speed := speed_min;						
					end if;
					exit trap_loop; 
 				end present;
 				
 				present quick_accel_pressed then
 					if (current_speed < speed_max) then
 						% set the speed
 						current_speed := current_speed + speed_inc;
				 		% Limits the speed
				 		if (current_speed > speed_max) then
							current_speed := speed_max;						
						end if;
						if (current_speed < speed_min) then
							current_speed := speed_min;						
						end if;
						exit trap_loop; 
 					end if;
 				end present;
 				
 				present quick_decel_pressed then
 					if (speed_min < current_speed) then
 						% set the speed
 						current_speed := current_speed - speed_inc;
 						% Limits the speed
				 		if (current_speed > speed_max) then
							current_speed := speed_max;						
						end if;
						if (current_speed < speed_min) then
							current_speed := speed_min;						
						end if;
						exit trap_loop; 
 					end if;
 				end present;
 				exit trap_loop;
 				
 			end if;
 			
 		end trap
 	end loop
 	
 end var
 
end module
 
 
 
 
 
 
 
 
 
 
 
